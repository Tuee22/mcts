#!python
import os
import subprocess

project_name = "_corridors_mcts"

# get argument flags
test = bool(ARGUMENTS.get('test',0))
debug = bool(ARGUMENTS.get('debug', 0))
profile = bool(ARGUMENTS.get('profile', 0))
sanitize = bool(ARGUMENTS.get('sanitize', 0))

# determine which files to build based on test flag
all_source_files = Glob('*.cpp')
exclude_from_test = ['_corridors_mcts.cpp']
exclude_from_prod = ['test.cpp']  # Use pybind11 version only

if test:
    exclude = exclude_from_test
    source_files = [f for f in all_source_files if str(f) not in exclude]
else:
    # For production, build pybind11 module only
    # Include all implementation files but build them as a single pybind11 module
    source_files = [f for f in all_source_files if str(f) not in exclude_from_prod]

# Python include and library configuration
python_includes = []
python_libs = []

if not test:
    # Get python config for current Python version
    python_includes = subprocess.check_output(['python3-config', '--includes'], 
                                             universal_newlines=True).strip().split()
    python_includes = [flag[2:] for flag in python_includes if flag.startswith('-I')]
    
    # Get python linker flags (use --embed for proper library linking)
    python_libs = subprocess.check_output(['python3-config', '--embed', '--ldflags'], 
                                         universal_newlines=True).strip().split()
    
    # Add pybind11 includes if available
    try:
        import pybind11
        python_includes.append(pybind11.get_include())
    except ImportError:
        # Fallback pybind11 paths
        python_includes.extend([
            '/usr/local/include',
            '/usr/include'
        ])

# determine compiler and linker flags
compiler_always_flags = [
    '-Wno-deprecated-declarations',
    '-std=c++17',  # Required for pybind11
    '-fPIC',
    '-Wall'
]

linker_always_flags = ['-shared'] if not test else []
optimization_maybe_flag = [] if debug else ['-O3']
debug_profile_maybe_flag = ['-pg'] if profile else ['-g'] if (test or debug) else []
fsanitize_maybe_flag = ['-fsanitize=address'] if sanitize else []

# determine env dict
flags = {
    'CCFLAGS': compiler_always_flags + optimization_maybe_flag + debug_profile_maybe_flag + fsanitize_maybe_flag,
    'LINKFLAGS': linker_always_flags + debug_profile_maybe_flag + fsanitize_maybe_flag,
}

print('Building pybind11 version (no Boost dependencies)')
print('Source files:', [str(f) for f in source_files])
print('Python includes:', python_includes)
print('Compiler flags:', flags)

env = Environment(**flags)

# build an executable if we're testing, otherwise build shared library
if test:
    build_method = env.Program
    target_name = project_name
    extra_args = {}
else:
    build_method = env.SharedLibrary
    target_name = project_name
    extra_args = {
        'SHLIBPREFIX': '',
        'SHLIBSUFFIX': '.so',  # Always use .so for Python modules, even on macOS
        'CPPPATH': python_includes,
        'LIBS': [lib.replace('-l', '') for lib in python_libs if lib.startswith('-l')],
        'LIBPATH': [lib.replace('-L', '') for lib in python_libs if lib.startswith('-L')]
    }

if test:
    result = build_method(
        target=target_name,
        source=source_files,
        **extra_args
    )
else:
    # Build extension into the centralized build directory
    target_path = '../build/' + target_name
    result = build_method(
        target=target_path,
        source=source_files,
        **extra_args
    )
    # Make this the default target
    Default(result)